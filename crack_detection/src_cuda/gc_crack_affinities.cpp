/*
 * Author: Xavier Gibert-Serra (gibert@umiacs.umd.edu)
 *
 * Copyright (C) 2013 University of Maryland. All rights reserved.
 *
 */

#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#ifdef UNIX
#include <stdint.h>
#endif

#include "mex.h"

#include <vector>

// CUDA
#include "cuda.h"
#include "cuda_runtime.h"

#include "GPUmat.hh"
#include "CracksCudaFunctions.h"
#include "ShearCudaFunctions.h"
#include "MexUtil.h"

// static paramaters
static CracksCudaFunctions func;
static ShearCudaFunctions funcShear;
static CracksGpuTimes* gt_cracks;
static GpuTimes* gt_shear;

static int init = 0;

static GPUmat *gm;

// Forward declarations

// Get sum of the elements of a vector
float getSum( const float* image_ptr, void* scratch_buf, int numElem );
// Allocate scratch memory for getSum() function
void* getSum_alloc( int numElem, gpuTYPE_t type_signal );
// Free scratch memory used by getSum() function
void getSum_free( void* pBuffer );

// This function takes a set of 16D low-level feature vectors generated by function
// llCrackFeatures and generates a graph structure that can be passed to graph-cut
//
// INPUTS: [0] features -- (width x height x 4N) feature vector
//         [1] gamma --
//         [2] lambda -- scale factor on the terminal capacities
//         [3] bias -- bias on the terminal capacities
// OUTPUT: [0] gc -- struct containing parameters for graph-cut function
void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
    // One-time initialization
    if (init == 0)
    {
        // Initialize function
        //mexLock();

        // load GPUmat
        gm = gmGetGPUmat();

        // load modules
        CUmodule *drvmod_cracks = gmGetModule("cracks_cuda");
        CUmodule *drvmod_shear = gmGetModule("shear_cuda");

        // Get timers
        gt_cracks = CracksGpuTimes::getGpuTimesObject();
        func.setTimer(gt_cracks);
        gt_shear = GpuTimes::getGpuTimesObject();
        funcShear.setTimer(gt_shear);

        // load GPU functions
        if( !func.LoadGpuFunctions( drvmod_cracks ) )
            mexErrMsgTxt("Unable to load GPU functions.");
        if( !funcShear.LoadGpuFunctions( drvmod_shear))
            mexErrMsgTxt("Unable to load GPU functions.");

        init = 1;
    }

    if( nrhs != 4)
        mexErrMsgTxt( "Incorrect number of input arguments" );
    if( nlhs != 1 )
        mexErrMsgTxt( "Incorrect number of output arguments" );

    // Check input arguments
    const mxArray* mx_features =  prhs[0];
    GPUtype gpu_features = gm->gputype.getGPUtype( mx_features );
    if( gm->gputype.getType( gpu_features ) != gpuFLOAT )
        mexErrMsgTxt( "Input features should be of type 'GPUsingle'" );
    if( gm->gputype.getNdims( gpu_features ) != 3 )
        mexErrMsgTxt( "Input features should be 3-dimensional" );
    const int* dims = gm->gputype.getSize( gpu_features );
    if( dims[2] != 16 )
        mexErrMsgTxt( "Input features should be of length 16" );
    int width = dims[0];
    int height = dims[1];
    int numElem = width * height;
    const float* ptr_features = static_cast<const float*>( gm->gputype.getGPUptr(gpu_features) );

    float gamma = (float)mxGetScalar(prhs[1]);
    float lambda = (float)mxGetScalar(prhs[2]);
    float bias = (float)mxGetScalar(prhs[3]);

    // Allocate output arguments
    int odims[2];  // Output dimensions
    odims[0] = dims[0];
    odims[1] = dims[1];
    GPUtype gpu_sum_fv = gm->gputype.create( gpuFLOAT, 2, odims, NULL );
    GPUtype gpu_dot_left = gm->gputype.create( gpuFLOAT, 2, odims, NULL );
    GPUtype gpu_dot_top = gm->gputype.create( gpuFLOAT, 2, odims, NULL ); 
    GPUtype gpu_dot_topleft = gm->gputype.create( gpuFLOAT, 2, odims, NULL ); 
    GPUtype gpu_dot_topright = gm->gputype.create( gpuFLOAT, 2, odims, NULL );
    float* ptr_sum_fv = (float*)const_cast<void*>( gm->gputype.getGPUptr(gpu_sum_fv) );
    float* ptr_dot_left = (float*)const_cast<void*>( gm->gputype.getGPUptr(gpu_dot_left) );
    float* ptr_dot_top = (float*)const_cast<void*>( gm->gputype.getGPUptr(gpu_dot_top) );
    float* ptr_dot_topleft = (float*)const_cast<void*>( gm->gputype.getGPUptr(gpu_dot_topleft) );
    float* ptr_dot_topright = (float*)const_cast<void*>( gm->gputype.getGPUptr(gpu_dot_topright) );

    // Calculate dot products
    func.dotProductsFeatures( ptr_features, 16, width, height, ptr_sum_fv,
                              ptr_dot_left, ptr_dot_top, ptr_dot_topleft, ptr_dot_topright );

    // Calculate beta
    void* d_scratch = getSum_alloc(width*height, gpuFLOAT);
    float meanDot = ( getSum(ptr_dot_left, d_scratch, numElem)
                    + getSum(ptr_dot_top, d_scratch, numElem)
                    + getSum(ptr_dot_topleft, d_scratch, numElem)
                    + getSum(ptr_dot_topright, d_scratch, numElem)
                    ) / (4.f * numElem);
    getSum_free(d_scratch);
    d_scratch = NULL;
    float beta = 1.f / (2.f + meanDot);

    // Allocate output arguments for graph weights
    // Due to limited support by GPUmat for the INT32 data type, we allocate the weights as FLOAT,
    // and then we cast them to INT32. To inspect the data from MATLAB, we need to call temp_GPUint32()
    GPUtype gpu_graph_terminals = gm->gputype.create( gpuFLOAT, 2, odims, NULL );
    GPUtype gpu_graph_left = gm->gputype.create( gpuFLOAT, 2, odims, NULL );
    GPUtype gpu_graph_right = gm->gputype.create( gpuFLOAT, 2, odims, NULL );
    GPUtype gpu_graph_top = gm->gputype.create( gpuFLOAT, 2, odims, NULL );
    GPUtype gpu_graph_topleft = gm->gputype.create( gpuFLOAT, 2, odims, NULL );
    GPUtype gpu_graph_topright = gm->gputype.create( gpuFLOAT, 2, odims, NULL );
    GPUtype gpu_graph_bottom = gm->gputype.create( gpuFLOAT, 2, odims, NULL );
    GPUtype gpu_graph_bottomleft = gm->gputype.create( gpuFLOAT, 2, odims, NULL );
    GPUtype gpu_graph_bottomright = gm->gputype.create( gpuFLOAT, 2, odims, NULL );
    int32_t* ptr_graph_terminals = (int32_t*)const_cast<void*>( gm->gputype.getGPUptr(gpu_graph_terminals) );
    int32_t* ptr_graph_left = (int32_t*)const_cast<void*>( gm->gputype.getGPUptr(gpu_graph_left) );
    int32_t* ptr_graph_right = (int32_t*)const_cast<void*>( gm->gputype.getGPUptr(gpu_graph_right) );
    int32_t* ptr_graph_top = (int32_t*)const_cast<void*>( gm->gputype.getGPUptr(gpu_graph_top) );
    int32_t* ptr_graph_topleft = (int32_t*)const_cast<void*>( gm->gputype.getGPUptr(gpu_graph_topleft) );
    int32_t* ptr_graph_topright = (int32_t*)const_cast<void*>( gm->gputype.getGPUptr(gpu_graph_topright) );
    int32_t* ptr_graph_bottom = (int32_t*)const_cast<void*>( gm->gputype.getGPUptr(gpu_graph_bottom) );
    int32_t* ptr_graph_bottomleft = (int32_t*)const_cast<void*>( gm->gputype.getGPUptr(gpu_graph_bottomleft) );
    int32_t* ptr_graph_bottomright = (int32_t*)const_cast<void*>( gm->gputype.getGPUptr(gpu_graph_bottomright) );

    // Calculate graph weights
    func.graphAffinitiesFromDotProd(ptr_dot_left, ptr_dot_top, ptr_dot_topleft, ptr_dot_topright,
                                    ptr_graph_left, ptr_graph_right, ptr_graph_top, ptr_graph_topleft,
                                    ptr_graph_topright, ptr_graph_bottom, ptr_graph_bottomleft, ptr_graph_bottomright,
                                    width, height, gamma, beta);
    func.graphTerminals(ptr_sum_fv, ptr_graph_terminals, width, height, lambda, bias);

    // Transpose left and right capacities
    //GPUtype gpu_graph_left_trans = gm->gputype.create( gpuFLOAT, 2, odims, NULL );
    //GPUtype gpu_graph_right_trans = gm->gputype.create( gpuFLOAT, 2, odims, NULL );
    GPUtype gpu_graph_left_trans = gm->numerics.TransposeDrv(gpu_graph_left);
    GPUtype gpu_graph_right_trans = gm->numerics.TransposeDrv(gpu_graph_right);

    // Return results
    const char *field_names[] = { "sum_fv", "dot_left", "dot_top", "dot_topleft", "dot_topright",
                                  "graph_terminals", "graph_left", "graph_right", "graph_top", "graph_topleft",
                                  "graph_topright", "graph_bottom", "graph_bottomleft", "graph_bottomright"
                                };
    const mwSize field_dims[2] = { 1, 1 };
    plhs[0] = mxCreateStructArray( 2, field_dims, 14, field_names );
    mxSetField( plhs[0], 0, "sum_fv", gm->gputype.createMxArray(gpu_sum_fv) );
    mxSetField( plhs[0], 0, "dot_left", gm->gputype.createMxArray(gpu_dot_left) );
    mxSetField( plhs[0], 0, "dot_top", gm->gputype.createMxArray(gpu_dot_top) );
    mxSetField( plhs[0], 0, "dot_topleft", gm->gputype.createMxArray(gpu_dot_topleft) );
    mxSetField( plhs[0], 0, "dot_topright", gm->gputype.createMxArray(gpu_dot_topright) );
    mxSetField( plhs[0], 0, "graph_terminals", gm->gputype.createMxArray(gpu_graph_terminals) );
    mxSetField( plhs[0], 0, "graph_left", gm->gputype.createMxArray(gpu_graph_left_trans) );
    mxSetField( plhs[0], 0, "graph_right", gm->gputype.createMxArray(gpu_graph_right_trans) );
    mxSetField( plhs[0], 0, "graph_top", gm->gputype.createMxArray(gpu_graph_top) );
    mxSetField( plhs[0], 0, "graph_topleft", gm->gputype.createMxArray(gpu_graph_topleft) );
    mxSetField( plhs[0], 0, "graph_topright", gm->gputype.createMxArray(gpu_graph_topright) );
    mxSetField( plhs[0], 0, "graph_bottom", gm->gputype.createMxArray(gpu_graph_bottom) );
    mxSetField( plhs[0], 0, "graph_bottomleft", gm->gputype.createMxArray(gpu_graph_bottomleft) );
    mxSetField( plhs[0], 0, "graph_bottomright", gm->gputype.createMxArray(gpu_graph_bottomright) );
}

// Allocate scratch memory for getSum() function
// The sum reduction kernel works by reducing the search space
// by 256 at each kernel invocation
void* getSum_alloc( int numElem, gpuTYPE_t type_signal )
{
    int elem_size_real = (type_signal == gpuDOUBLE || type_signal == gpuCDOUBLE  ?
                     sizeof(double) : sizeof(float));
    int buffer_len = 0;

    // Calculate elements needed for each iteration
    while( numElem > 1 )
    {
        numElem = iDivUp(numElem, 256);
        buffer_len += numElem;
    }

    // Allocate memory
    void* buffer_ptr;
    cmexSafeCall( cudaMalloc( &buffer_ptr, buffer_len * elem_size_real));
    return buffer_ptr;
}

// Free scratch memory used by getSum() function
void getSum_free( void* pBuffer )
{
    cmexSafeCall( cudaFree( pBuffer ) );
}

// Get the sum of the elements of a vector (Note: this function assumes that numElem > 1)
float getSum( const float* image_ptr, void* scratch_buf, int numElem )
{
    const float* buffer_src = image_ptr;
    float* buffer_dst = (float*)scratch_buf;

    // Reduce summations until there are no elements left
    while( numElem > 1 )
    {
        funcShear.reduceSum256( buffer_dst, buffer_src, numElem, gpuFLOAT );
        buffer_src = buffer_dst;
        numElem = iDivUp(numElem, 256);
        buffer_dst += numElem;
    }

    // Transfer result
    float h_Sum;
    cmexSafeCall( cudaMemcpy( &h_Sum, buffer_src, sizeof(h_Sum), cudaMemcpyDeviceToHost ));
    return h_Sum;
}
